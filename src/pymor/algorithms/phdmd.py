# This file is part of the pyMOR project (https://www.pymor.org).
# Copyright pyMOR developers and contributors. All rights reserved.
# License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)

import numpy as np
import scipy.linalg as spla

from pymor.core.exceptions import PHDMDError
from pymor.core.logger import getLogger
from pymor.models.iosys import PHLTIModel


def phdmd(X, U, Y, Xdot=None, dt=None, H=None, initial_J=None, initial_R=None, initial_alpha=0.1, miniter=0,
          maxiter=30, atol=1e-12, rtol=1e-10, weighted_rtol=1e-12, skew_procrustes_rtol=1e-12):
    r"""Solve the pH DMD problem.

    This method solves the optimization problem

    .. math::
        \min_{J, R} \lVert Z - (J - R) T \rVert_F

    such that :math:`J \in \mathbb{R}^{(n + m) \times (n + m)}` is skew symmetric and
    :math:`R \in \mathbb{R}^{(n + m) \times (n + m)}` is symmetric positive semidefinite.
    The data matrices :math:`T \in \mathbb{R}^{(n + m) \times k}` and
    :math:`Z \in \mathbb{R}^{(n + m) \times k}` are constructed as

    .. math::
        T =
        \begin{bmatrix}
          X \\
          U
        \end{bmatrix}\!,\
        Z =
        \begin{bmatrix}
          H \dot{X} \\
          -Y
        \end{bmatrix}

    from
    state data :math:`X \in \mathbb{R}^{n \times k}`,
    input data :math:`U \in \mathbb{R}^{m \times k}`,
    output data :math:`Y \in \mathbb{R}^{m \times k}`,
    Hamiltonian :math:`H \in \mathbb{R}^{n \times n}`, and
    either derivative :math:`\dot{X} \in \mathbb{R}^{n \times k}`
    or an approximation of the derivative data obtained from :math:`X` itself.

    The formal description of this algorithm can be found in :cite:`MMU23`.

    Parameters
    ----------
    X
        The |NumPy array| of the system state data of shape `(n, k)`.
    U
        The |NumPy array| of the system input data of shape `(m, k)`.
    Y
        The |NumPy array| of the system output data of shape `(m, k)`.
    Xdot
        If not `None`, the |NumPy array| of the system time derivative data of shape `(n, k)`.
        If `None`, `dt` will be used to estimate this data from `X` using
        an implicit midpoint rule.
    dt
        See `Xdot`.
    H
        If not `None`, the |NumPy array| of the system Hamiltonian of shape `(n, n)`.
    initial_J
        If not `None`, the |NumPy array| representing the initial guess for :math:`J`.
    initial_R
        If not `None`, the |NumPy array| representing the initial guess for :math:`R`.
    initial_alpha
        The initial value used in calculating the update step.
    miniter
        Minimum amount of iterations to perform.
    maxiter
        Fail if the iteration count reaches this value without converging.
    atol
        Finish when the absolute error measure is below this threshold.
    rtol
        Finish when the relative update error measure is below this threshold.
    weighted_rtol
        In the weighted pH DMD initialization problem, truncate when the relative value is
        below this threshold.
    skew_procrustes_rtol
        In the skew-symmetric Procrustes problem, truncate when the relative value is
        below this threshold.

    Returns
    -------
    inf_model
        The inferred |PHLTIModel|.
    data
        Dict containing the following fields:

        :update_norms:          |NumPy array| of the norms of the update vectors after
                                each iteration.
        :abs_errs:              |NumPy array| of the absolute errors after each iteration.
        :rel_errs:              |NumPy array| of the relative  errors after each iteration.
        :iterations:            Number of total pH DMD iterations.
        :skew_procrustes_data:  `list` of data generated by the skew-symmetric
                                Procrustes subproblems.
        :weighted_init_data:    If `initial_J` and `initial_R` are both `None`, dict of data
                                generated by the weighted pH DMD initialization subproblem.
        :skew_init_data:        If only `initial_J` is `None`, dict of data generated by the
                                skew-symmetric Procrustes subproblem.
        :spsd_init_data:        If only `initial_R` is `None`, dict of data generated by the PSD
                                symmetric Procrustes subproblem.
    """
    assert isinstance(X, np.ndarray)
    assert isinstance(U, np.ndarray)
    assert isinstance(Y, np.ndarray)
    assert X.shape[1] == U.shape[1]
    assert X.shape[1] == Y.shape[1]
    assert U.shape[0] == Y.shape[0]
    assert 0. < initial_alpha < 1.

    logger = getLogger('pymor.algorithms.phdmd.phdmd')

    if Xdot is None:
        assert dt is not None
        Xdot = (X[:, 1:] - X[:, :-1]) / dt
    else:
        assert isinstance(Xdot, np.ndarray)
        assert X.shape[0] == Xdot.shape[0]
        assert X.shape[1] == Xdot.shape[1]
        Xdot = .5 * (Xdot[:, 1:] + Xdot[:, :-1])

    X = (X[:, 1:] + X[:, :-1]) / 2
    U = (U[:, 1:] + U[:, :-1]) / 2
    Y = (Y[:, 1:] + Y[:, :-1]) / 2

    state_dim = X.shape[0]

    if H is None:
        logger.warn('No H matrix provided. Did you intend this?')
        H = np.eye(state_dim)

    assert isinstance(H, np.ndarray)
    assert H.shape[0] == H.shape[1]
    assert H.shape[0] == state_dim

    T = np.vstack([X, U])
    Z = np.vstack([H @ Xdot, -Y])
    data = {}

    if initial_J is None and initial_R is not None:
        assert isinstance(initial_R, np.ndarray)
        assert initial_R.shape[0] == T.shape[0]
        assert initial_R.shape[1] == T.shape[0]
        logger.info('Solving skew-symmetric Procrustes problem to get initial J...')
        initial_J, skew_data = _skew_symmetric_procrustes(T, initial_R @ T + Z, rtol=skew_procrustes_rtol)
        data['skew_init_data'] = skew_data
    elif initial_J is not None and initial_R is None:
        assert isinstance(initial_J, np.ndarray)
        assert initial_J.shape[0] == T.shape[0]
        assert initial_J.shape[1] == T.shape[0]
        logger.info('Solving SPSD Procrustes problem to get initial R...')
        initial_R, spsd_data = _initial_spsd_procrustes(T, initial_J @ T - Z)
        data['spsd_init_data'] = spsd_data
    elif initial_J is None and initial_R is None:
        logger.info('Solving weighted problem to get initial J and R...')
        initial_J, initial_R, weighted_data = _weighted_phdmd(T, Z, rtol=weighted_rtol)
        data['weighted_init_data'] = weighted_data

    assert isinstance(initial_J, np.ndarray)
    assert isinstance(initial_R, np.ndarray)
    assert initial_J.shape[0] == T.shape[0]
    assert initial_J.shape[1] == T.shape[0]
    assert initial_R.shape[0] == T.shape[0]
    assert initial_R.shape[1] == T.shape[0]

    J = initial_J
    R = initial_R

    logger.info('Running pH DMD algorithm...')

    sing_vals = spla.svdvals(T)
    L = sing_vals.max()
    mu = sing_vals.max()
    sing_ratio = mu / L

    alphas = [initial_alpha]
    betas = []
    abs_errs = [spla.norm(Z - (J - R) @ T)]
    rel_errs = [abs_errs[0] / spla.norm(Z)]
    update_norms = []
    procrustes_data = []

    Q = R
    iteration = 0
    update_norm = np.inf
    while True:
        logger.info(f'Starting pH DMD algorithm iteration {iteration} with '
                    f'current errors abs: {abs_errs[-1]} rel: {rel_errs[-1]}...')

        if iteration >= miniter:
            msg = f'pH DMD converged in {iteration} iterations because {{}} tolerance of {{}} was reached.'
            if abs_errs[-1] < atol:
                logger.info(msg.format('absolute error', atol))
                break
            if rel_errs[-1] < rtol:
                logger.info(msg.format('relative error', rtol))
                break
            if update_norm < rtol:
                logger.info(msg.format('relative update', rtol))
                break
            if iteration >= maxiter:
                logger.info(f'Maximum iterations reached. Failed to converge after {iteration} iterations.')
                raise PHDMDError('Failed to converge after the maximum amount of iterations.')

        iteration += 1

        R_prev = R
        J_prev = J
        last_alpha = alphas[-1]

        Z_1 = Z + R @ T
        logger.info('Solving skew-symmetric Procrustes subproblem...')
        J, skew_procrustes_data = _skew_symmetric_procrustes(T, Z_1, rtol=skew_procrustes_rtol)
        procrustes_data.append(skew_procrustes_data)
        Z_2 = J @ T - Z
        G = Q @ T @ T.T - Z_2 @ T.T
        R = _project_spsd(Q - G / L)

        alpha = np.sqrt((last_alpha ** 2 - sing_ratio) ** 2 + 4 * last_alpha ** 2)
        alpha += sing_ratio - last_alpha ** 2
        alpha /= 2.
        beta = last_alpha * (1 - last_alpha) / (last_alpha ** 2 + alpha)
        Q = R + beta * (R - R_prev)

        alphas.append(alpha)
        betas.append(beta)

        abs_errs.append(spla.norm(Z - (J - R) @ T))
        rel_errs.append(abs_errs[-1] / spla.norm(Z))
        update_norm = spla.norm(J_prev - J) / spla.norm(J) + spla.norm(R_prev - R) / spla.norm(J)
        update_norms.append(update_norm)

    data['update_norms'] = np.array(update_norms)
    data['abs_errs'] = np.array(abs_errs)
    data['rel_errs'] = np.array(rel_errs)
    data['iterations'] = iteration
    data['skew_procrustes_data'] = procrustes_data

    inf_J = J[:state_dim, :state_dim]
    inf_G = J[:state_dim, state_dim:]
    inf_N = J[state_dim:, state_dim:]
    inf_R = R[:state_dim, :state_dim]
    inf_P = R[:state_dim, state_dim:]
    inf_S = R[state_dim:, state_dim:]
    inf_model = PHLTIModel.from_matrices(
        J=inf_J, R=inf_R, G=inf_G, P=inf_P, N=inf_N, S=inf_S, E=H
    )

    return inf_model, data


def _weighted_phdmd(T, Z, rtol=1e-12):
    r"""Solve the weighted pH DMD problem.

    This method solves the optimization problem

    .. math::
        min_{J, R} \lVert T^T Z - T^T (J - R) T \rVert_F

    such that :math:`J` is skew symmetric and :math:`R` is symmetric positive semidefinite.

    Not intended to be used directly.

    Parameters
    ----------
    T
        See `phdmd`.
    Z
        See `phdmd`.
    rtol
        Truncate the singular values when the ratio with respect to the largest singular value
        is below this threshold.

    Returns
    -------
    J
        The |NumPy array| for `J`.
    R
        The |NumPy array| for `R`.
    data
        Dict containing the following fields:

        :abs:   Value of absolute solution error.
        :rel:   Value of relative solution error.
    """
    assert isinstance(T, np.ndarray)
    assert isinstance(Z, np.ndarray)
    assert T.shape[0] == Z.shape[0]
    assert T.shape[1] == Z.shape[1]
    assert rtol < 1

    logger = getLogger('pymor.algorithms.phdmd._weighted_phdmd')

    data_dim = T.shape[0]

    V, s_vals, Wh = spla.svd(T, full_matrices=False, lapack_driver='gesvd')
    W = Wh.T

    rank = np.sum(s_vals / s_vals[0] > rtol)

    V1 = V[:, :rank]
    s1 = s_vals[:rank]

    if rank < data_dim:
        logger.warn(f'Deficient rank ({rank} < {data_dim})!')

    Z1 = V.T @ Z @ W

    tZ1 = s1[:, np.newaxis] * Z1[:rank, :rank]
    J11 = (tZ1 - tZ1.T) / 2
    R11 = _project_spsd(-tZ1)
    J = V1 @ (s1[:, np.newaxis] * J11 * s1) @ V1.T
    R = V1 @ (s1[:, np.newaxis] * R11 * s1) @ V1.T

    if rank < data_dim:
        J21 = Z1[rank:, :rank] / s1
        compensation = np.zeros((data_dim, data_dim))
        compensation[rank:, :rank] = J21
        compensation[:rank, rank:] = -J21.T
        J = J + V @ compensation @ V.T

    abs_err = spla.norm(T.T @ Z - T.T @ (J - R) @ T)
    rel_err = abs_err / spla.norm(T.T @ Z)
    data = {'abs': abs_err, 'rel': rel_err}

    return J, R, data


def _project_spsd(matrix):
    """Project the matrix onto the set of symmetric positive semidefinite matrices.

    Not intended to be used directly.

    Parameters
    ----------
    matrix
        The |NumPy array| containing the matrix to project.
    """
    assert isinstance(matrix, np.ndarray)
    assert matrix.shape[0] == matrix.shape[1]

    matrix = (matrix + matrix.T) / 2
    eig_vals, eig_vecs = spla.eigh(matrix)
    return (eig_vecs * eig_vals.clip(min=0)) @ eig_vecs.T


def _skew_symmetric_procrustes(T, Z, rtol=1e-12):
    r"""Solve the skew-symmetric Procrustes problem.

    Computes a solution :math:`J` of the minimization problem

    .. math::
        \min_{J} \lVert Z - J T \rVert_F

    used in the pH DMD algorithm, such that :math:`J` is skew symmetric.

    Not intended to be used directly.

    Parameters
    ----------
    T
        See `phdmd`.
    Z
        See `phdmd`.
    rtol
        Truncate the singular values and matrix entries of :math:`J` when the ratio with respect
        to the largest value is below this threshold.

    Returns
    -------
    J
        The |NumPy array| containing the matrix mapping `T` to `Z`.
    data
        Dict containing the following fields:

        :abs:   Value of absolute fitting error.
        :rel:   Value of relative fitting error.
    """
    assert isinstance(T, np.ndarray)
    assert isinstance(Z, np.ndarray)
    assert T.shape[0] == Z.shape[0]
    assert T.shape[1] == Z.shape[1]
    assert rtol < 1

    data_dim = T.shape[0]

    V, s_vals, Wh = spla.svd(T, lapack_driver='gesvd')
    W = Wh.T

    rank = np.sum(s_vals / s_vals[0] > rtol)
    s1 = s_vals[:rank]

    Y_trans = V @ Z @ W[:rank].T
    Z1 = Y_trans[:rank]
    Z3 = Y_trans[rank:]

    Phi = 1. / (s1[:, np.newaxis]**2 + s1**2)
    Z1_S1 = Z1 * s1
    J1 = Phi * (Z1_S1 - Z1_S1.T)
    J2 = Z3 / s1[: np.newaxis]
    J4 = np.zeros((data_dim - rank, data_dim - rank))
    J = np.block([
        [J1, -J2.T],
        [J2, J4]
    ])
    J = V @ J @ V.T

    J_abs = np.abs(J)
    indices = np.where(J_abs / J_abs.max() < rtol)
    J[indices] = 0.

    abs_err = spla.norm(Z - J @ T)
    rel_err = abs_err / spla.norm(Z)
    data = {'abs': abs_err, 'rel': rel_err}

    return J, data


def _initial_spsd_procrustes(T, Z, reg=1e-6):
    r"""Solve the SPSD Procrustes problem.

    Computes a solution R of the minimization problem

    .. math::
        \min_{R} \lVert Z - R T \rVert_F

    used as an initial guess in the pH DMD algorithm such that :math:`R` is
    symmetric positive semidefinite.

    Not intended to be used directly.

    Parameters
    ----------
    T
        See `phdmd`.
    Z
        See `phdmd`.
    reg
        Regularization parameter applied to every element on the main diagonal
        to avoid singular matrices.

    Returns
    -------
    R
        The `NumPy array` containing the matrix mapping `T` to `Z`.
    data
        Dict containing the following fields:

        :abs:   Value of absolute fitting error.
        :rel:   Value of relative fitting error.
    """
    assert isinstance(T, np.ndarray)
    assert isinstance(Z, np.ndarray)
    assert T.shape[0] == Z.shape[0]
    assert T.shape[1] == Z.shape[1]
    assert reg >= 0

    data_dim = T.shape[0]

    R = np.zeros((data_dim, data_dim))
    for i in range(data_dim):
        T_row = T[i]
        R[i, i] = max(0, T_row.dot(Z[i])) / spla.norm(T_row) ** 2 + reg

    abs_err = spla.norm(Z - R @ T)
    rel_err = abs_err / spla.norm(Z)
    data = {'abs': abs_err, 'rel': rel_err}

    return R, data
