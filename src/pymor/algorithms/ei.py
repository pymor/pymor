# This file is part of the pyMOR project (http://www.pymor.org).
# Copyright Holders: Rene Milk, Stephan Rave, Felix Schindler
# License: BSD 2-Clause License (http://opensource.org/licenses/BSD-2-Clause)

"""This module contains algorithms for the empirical interpolation of operators.

The main work for generating the necessary interpolation data is handled by
the :func:`ei_greedy` method. The objects returned by this method can be used
to instantiate an |EmpiricalInterpolatedOperator|.

As a convenience, the :func:`interpolate_operators` method allows to perform
the empirical interpolation of the |Operators| of a given discretization with
a single function call.
"""

from __future__ import absolute_import, division, print_function

import numpy as np

from pymor.algorithms.gram_schmidt import gram_schmidt
from pymor.core.logger import getLogger
from pymor.algorithms.pod import pod
from pymor.operators.ei import EmpiricalInterpolatedOperator
from pymor.vectorarrays.interfaces import VectorArrayInterface


def ei_greedy(U, error_norm=None, target_error=None, max_interpolation_dofs=None,
              projection='ei', product=None, copy=True):
    """Generate data for empirical interpolation by a greedy search (EI-Greedy algorithm).

    Given a |VectorArray| `U`, this method generates a collateral basis and
    interpolation DOFs for empirical interpolation of the vectors contained in `U`.
    The returned objects can also be used to instantiate an |EmpiricalInterpolatedOperator|.

    The interpolation data is generated by a greedy search algorithm, adding in each
    loop the worst approximated vector in `U` to the collateral basis.

    Parameters
    ----------
    U
        A |VectorArray| of vectors to interpolate.
    error_norm
        Norm w.r.t. which to calculate the interpolation error. If `None`, the Euclidean norm
        is used.
    target_error
        Stop the greedy search if the largest approximation error is below this threshold.
    max_interpolation_dofs
        Stop the greedy search if the number of interpolation DOF (= dimension of the collateral
        basis) reaches this value.
    projection
        If `ei`, compute the approximation error by comparing the given vector by its
        interpolant. If `orthogonal`, compute the error by comparing with the orthogonal projection
        onto the span of the collateral basis.
    product
        If `projection == 'orthogonal'`, the product which is used to perform the projection.
        If `None`, the Euclidean product is used.
    copy
        If `False`, `U` will be modified during executing of the algorithm.

    Returns
    -------
    interpolation_dofs
        |NumPy array| of the DOFs at which the vectors are evaluated.
    collateral_basis
        |VectorArray| containing the generated collateral basis.
    data
        Dict containing the following fields:

            :errors:                Sequence of maximum approximation errors during
                                    greedy search.
            :triangularity_errors:  Sequence of maximum absolute values of interoplation
                                    matrix coefficients in the upper triangle (should
                                    be near zero).
    """

    assert projection in ('orthogonal', 'ei')
    assert isinstance(U, VectorArrayInterface)

    logger = getLogger('pymor.algorithms.ei.ei_greedy')
    logger.info('Generating Interpolation Data ...')

    interpolation_dofs = np.zeros((0,), dtype=np.int32)
    collateral_basis = U.empty()
    max_errs = []
    triangularity_errs = []

    if copy:
        U = U.copy()

    if projection == 'orthogonal':
        ERR = U.copy()
        onb_collateral_basis = collateral_basis.empty()
    else:
        ERR = U

    # main loop
    while True:
        errs = ERR.l2_norm() if error_norm is None else error_norm(ERR)
        max_err_ind = np.argmax(errs)
        max_err = errs[max_err_ind]

        if len(interpolation_dofs) >= max_interpolation_dofs:
            logger.info('Maximum number of interpolation DOFs reached. Stopping extension loop.')
            logger.info('Final maximum {0} error with {1} interpolation DOFs: {2}'.format(
                'projection' if projection else 'interpolation', len(interpolation_dofs), max_err))
            break

        logger.info('Maximum {0} error with {1} interpolation DOFs: {2}'
                    .format('projection' if projection else 'interpolation',
                            len(interpolation_dofs), max_err))

        if target_error is not None and max_err <= target_error:
            logger.info('Target error reached! Stopping extension loop.')
            break

        # compute new interpolation dof and collateral basis vector
        new_vec = U.copy(ind=max_err_ind)
        new_dof = new_vec.amax()[0][0]
        if new_dof in interpolation_dofs:
            logger.info('DOF {0} selected twice for interplation! Stopping extension loop.'.format(new_dof))
            break
        new_dof_value = new_vec.components([new_dof])[0, 0]
        if new_dof_value == 0.:
            logger.info('DOF {0} selected for interpolation has zero maximum error! Stopping extension loop.'
                        .format(new_dof))
            break
        new_vec *= 1 / new_dof_value
        interpolation_dofs = np.hstack((interpolation_dofs, new_dof))
        collateral_basis.append(new_vec)
        max_errs.append(max_err)

        # update U and ERR
        new_dof_values = U.components([new_dof])
        U.axpy(-new_dof_values[:, 0], new_vec)
        if projection == 'orthogonal':
            onb_collateral_basis.append(new_vec)
            gram_schmidt(onb_collateral_basis, offset=len(onb_collateral_basis) - 1, copy=False)
            coeffs = ERR.dot(onb_collateral_basis, o_ind=len(onb_collateral_basis) - 1)
            ERR.axpy(-coeffs[:, 0], onb_collateral_basis, x_ind=len(onb_collateral_basis) - 1)

    interpolation_matrix = collateral_basis.components(interpolation_dofs).T
    triangularity_errors = np.abs(interpolation_matrix - np.tril(interpolation_matrix))
    for d in range(1, len(interpolation_matrix) + 1):
        triangularity_errs.append(np.max(triangularity_errors[:d, :d]))

    logger.info('Interpolation matrix is not lower triangular with maximum error of {0}'
                .format(triangularity_errs[-1]))
    logger.info('')

    data = {'errors': max_errs, 'triangularity_errors': triangularity_errs}

    return interpolation_dofs, collateral_basis, data


def deim(U, modes=None, error_norm=None, product=None):
    """Generate data for empirical interpolation using DEIM algorithm.

    Given a |VectorArray| `U`, this method generates a collateral basis and
    interpolation DOFs for empirical interpolation of the vectors contained in `U`.
    The returned objects can also be used to instantiate an |EmpiricalInterpolatedOperator|.

    The collateral basis is determined by the first :func:`~pymor.algorithms.pod.pod` modes of `U`.

    Parameters
    ----------
    U
        A |VectorArray| of vectors to interpolate.
    modes
        Dimension of the collateral basis i.e. number of POD modes of the vectors in `U`.
    error_norm
        Norm w.r.t. which to calculate the interpolation error. If `None`, the Euclidean norm
        is used.
    product
        Product |Operator| used for POD.

    Returns
    -------
    interpolation_dofs
        |NumPy array| of the DOFs at which the vectors are interpolated.
    collateral_basis
        |VectorArray| containing the generated collateral basis.
    data
        Dict containing the following fields:

            :errors: Sequence of maximum approximation errors during greedy search.
    """

    assert isinstance(U, VectorArrayInterface)

    logger = getLogger('pymor.algorithms.ei.deim')
    logger.info('Generating Interpolation Data ...')

    collateral_basis = pod(U, modes, product=product)[0]

    interpolation_dofs = np.zeros((0,), dtype=np.int32)
    interpolation_matrix = np.zeros((0, 0))
    errs = []

    for i in xrange(len(collateral_basis)):

        if len(interpolation_dofs) > 0:
            coefficients = np.linalg.solve(interpolation_matrix,
                                           collateral_basis.components(interpolation_dofs, ind=i).T).T
            U_interpolated = collateral_basis.lincomb(coefficients, ind=range(len(interpolation_dofs)))
            ERR = collateral_basis.copy(ind=i)
            ERR -= U_interpolated
        else:
            ERR = collateral_basis.copy(ind=i)

        err = ERR.l2_norm() if error_norm is None else error_norm(ERR)

        logger.info('Interpolation error for basis vector {0}: {1}'.format(i, err))

        # compute new interpolation dof and collateral basis vector
        new_dof = ERR.amax()[0][0]

        if new_dof in interpolation_dofs:
            logger.info('DOF {0} selected twice for interplation! Stopping extension loop.'.format(new_dof))
            break

        interpolation_dofs = np.hstack((interpolation_dofs, new_dof))
        interpolation_matrix = collateral_basis.components(interpolation_dofs, ind=range(len(interpolation_dofs))).T
        errs.append(err)

        logger.info('')

    if len(interpolation_dofs) < len(collateral_basis):
        collateral_basis.remove(ind=range(len(interpolation_dofs), len(collateral_basis)))

    logger.info('Finished.'.format(new_dof))

    data = {'errors': errs}

    return interpolation_dofs, collateral_basis, data


def interpolate_operators(discretization, operator_names, parameter_sample, error_norm=None,
                          target_error=None, max_interpolation_dofs=None,
                          projection='ei', product=None):
    """Empirical operator interpolation using the EI-Greedy algorithm.

    This is a convenience method for facilitating the use of :func:`ei_greedy`. Given
    a |Discretization|, names of |Operators|, and a sample of |Parameters|, first the operators
    are evaluated on the solution snapshots of the discretization for the provided parameters.
    These evaluations are then used as input for :func:`ei_greedy`. Finally the resulting
    interpolation data is used to create |EmpiricalInterpolatedOperators| and a new
    discretization with the interpolated operators is returned.

    Note that this implementation creates ONE common collateral basis for all specified
    operators which might not be what you want.

    Parameters
    ----------
    discretization
        The |Discretization| whose |Operators| will be interpolated.
    operator_names
        List of keys in the `operators` dict of the discretization. The corresponding
        |Operators| will be interpolated.
    parameter_sample
        A list of |Parameters| for which solution snapshots are calculated.
    error_norm
        See :func:`ei_greedy`.
    target_error
        See :func:`ei_greedy`.
    max_interpolation_dofs
        See :func:`ei_greedy`.
    projection
        See :func:`ei_greedy`.
    product
        See :func:`ei_greedy`.

    Returns
    -------
    ei_discretization
        |Discretization| with |Operators| given by `operator_names` replaced by
        |EmpiricalInterpolatedOperators|.
    data
        Dict containing the following fields:

            :dofs:    |NumPy array| of the DOFs at which the |Operators| have to be evaluated.
            :basis:   |VectorArray| containing the generated collateral basis.
            :errors:  Sequence of maximum approximation errors during greedy search.
    """

    operators = [discretization.operators[operator_name] for operator_name in operator_names]

    evaluations = operators[0].range.empty()
    for mu in parameter_sample:
        U = discretization.solve(mu)
        for op in operators:
            evaluations.append(op.apply(U, mu=mu))

    dofs, basis, data = ei_greedy(evaluations, error_norm, target_error, max_interpolation_dofs,
                                  projection=projection, product=product, copy=False)

    ei_operators = {name: EmpiricalInterpolatedOperator(operator, dofs, basis, triangular=True)
                    for name, operator in zip(operator_names, operators)}
    operators_dict = discretization.operators.copy()
    operators_dict.update(ei_operators)
    ei_discretization = discretization.with_(operators=operators_dict, name='{0}_ei'.format(discretization.name))

    data.update({'dofs': dofs, 'basis': basis})
    return ei_discretization, data
